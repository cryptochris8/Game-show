<!-- BUZZCHAIN TRIVIA - Game Board UI -->
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600;700&display=swap');

  :root {
    --primary-gold: #FFD700;
    --secondary-gold: #FFA500;
    --dark-bg: #0a0a0f;
    --card-bg: rgba(20, 20, 30, 0.95);
    --accent-blue: #00BFFF;
    --success-green: #00FF88;
    --error-red: #FF4444;
    --text-light: #FFFFFF;
    --text-dim: #CCCCCC;
    --shadow-glow: 0 0 30px rgba(255, 215, 0, 0.3);
    --animation-speed: 0.3s;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Exo 2', sans-serif;
    background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
    color: var(--text-light);
    min-height: 100vh;
    overflow: hidden;
  }

  /* Main Game Container */
  .game-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
  }

  /* Top Bar with Logo and Timer */
  .top-bar {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem 2rem;
    background: var(--card-bg);
    border-bottom: 2px solid var(--primary-gold);
    position: relative;
  }

  .game-logo {
    display: flex;
    align-items: center;
    gap: 1rem;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }

  .logo-text {
    font-family: 'Orbitron', monospace;
    font-size: 1.5rem;
    font-weight: 900;
    background: linear-gradient(45deg, var(--primary-gold), var(--secondary-gold));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .round-info {
    text-align: center;
    position: absolute;
    left: 2rem;
  }

  .round-label {
    color: var(--text-dim);
    font-size: 0.9rem;
    text-transform: uppercase;
  }

  .round-name {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--primary-gold);
  }

  .timer {
    font-family: 'Orbitron', monospace;
    font-size: 1.5rem;
    color: var(--accent-blue);
    min-width: 100px;
    text-align: center;
    position: absolute;
    right: 2rem;
  }

  /* Game Board */
  .board-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1rem;
    overflow: auto;
  }

  .game-board {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: auto repeat(5, 1fr);
    gap: 0.5rem;
    max-width: 1400px;
    margin: 0 auto;
    width: 100%;
    height: 100%;
  }

  /* Category Headers */
  .category-header {
    background: linear-gradient(135deg, var(--primary-gold), var(--secondary-gold));
    color: var(--dark-bg);
    padding: 1rem;
    text-align: center;
    font-weight: 700;
    font-size: 1.1rem;
    text-transform: uppercase;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 60px;
  }

  /* Clue Cells */
  .clue-cell {
    background: var(--card-bg);
    border: 2px solid var(--primary-gold);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Orbitron', monospace;
    font-size: 2rem;
    font-weight: 700;
    color: var(--primary-gold);
    cursor: pointer;
    transition: all var(--animation-speed) ease;
    position: relative;
    overflow: hidden;
  }

  .clue-cell:hover:not(.answered) {
    transform: scale(1.05);
    box-shadow: var(--shadow-glow);
    border-color: var(--text-light);
  }

  .clue-cell.answered {
    background: rgba(40, 40, 50, 0.5);
    border-color: rgba(255, 215, 0, 0.2);
    color: rgba(255, 215, 0, 0.3);
    cursor: not-allowed;
  }

  .clue-cell.daily-double {
    animation: pulseGold 2s ease-in-out infinite;
  }

  @keyframes pulseGold {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
  }

  /* Players Section */
  .players-section {
    background: var(--card-bg);
    border-top: 2px solid var(--primary-gold);
    padding: 1rem 2rem;
  }

  .players-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    max-width: 1400px;
    margin: 0 auto;
  }

  .player-card {
    text-align: center;
    padding: 1rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.05);
    min-width: 150px;
    transition: all var(--animation-speed) ease;
  }

  .player-card.current-turn {
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
    border: 2px solid var(--primary-gold);
    animation: turnPulse 2s ease-in-out infinite;
  }

  @keyframes turnPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  /* Flash animations for buzz feedback */
  @keyframes flashGreen {
    0%, 100% { background-color: inherit; }
    50% { background-color: rgba(0, 255, 136, 0.1); }
  }

  @keyframes flashRed {
    0%, 100% { background-color: inherit; }
    50% { background-color: rgba(255, 68, 68, 0.1); }
  }

  .player-card.buzzer-winner {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 191, 255, 0.2));
    border: 2px solid var(--success-green);
  }

  .player-name {
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: var(--text-light);
  }

  .player-score {
    font-family: 'Orbitron', monospace;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--primary-gold);
  }

  .player-score.negative {
    color: var(--error-red);
  }

  .player-indicator {
    font-size: 0.8rem;
    color: var(--accent-blue);
    margin-top: 0.3rem;
    height: 1rem;
  }

  /* Question Modal */
  .question-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    animation: fadeIn 0.3s ease;
  }

  .question-modal.active {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .question-content {
    background: var(--card-bg);
    border: 3px solid var(--primary-gold);
    border-radius: 20px;
    padding: 3rem;
    max-width: 800px;
    width: 90%;
    text-align: center;
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn {
    from { transform: translateY(-50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .question-value {
    font-family: 'Orbitron', monospace;
    font-size: 2rem;
    color: var(--primary-gold);
    margin-bottom: 1rem;
  }

  .question-category {
    font-size: 1.2rem;
    color: var(--text-dim);
    text-transform: uppercase;
    margin-bottom: 2rem;
  }

  .question-text {
    font-size: 1.8rem;
    line-height: 1.5;
    margin-bottom: 2rem;
    color: var(--text-light);
  }

  .question-timer {
    font-family: 'Orbitron', monospace;
    font-size: 3rem;
    color: var(--accent-blue);
    margin-bottom: 2rem;
  }

  .question-timer.warning {
    color: var(--secondary-gold);
    animation: timerPulse 1s ease-in-out infinite;
  }

  .question-timer.danger {
    color: var(--error-red);
    animation: timerPulse 0.5s ease-in-out infinite;
  }

  @keyframes timerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  /* Buzz Button */
  .buzz-container {
    margin-top: 2rem;
  }

  .buzz-button {
    background: linear-gradient(135deg, var(--error-red), #FF6666);
    color: var(--text-light);
    border: none;
    border-radius: 50%;
    width: 150px;
    height: 150px;
    font-size: 2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all var(--animation-speed) ease;
    box-shadow: 0 10px 30px rgba(255, 68, 68, 0.3);
  }

  .buzz-button:hover:not(:disabled) {
    transform: scale(1.1);
    box-shadow: 0 15px 40px rgba(255, 68, 68, 0.5);
  }

  .buzz-button:active:not(:disabled) {
    transform: scale(0.95);
  }

  .buzz-button:disabled {
    background: rgba(100, 100, 100, 0.5);
    cursor: not-allowed;
    opacity: 0.5;
  }

  /* Answer Input */
  .answer-container {
    display: none;
    margin-top: 2rem;
    width: 100%;
    text-align: center;
    background: rgba(255, 215, 0, 0.1);
    border: 2px solid var(--primary-gold);
    border-radius: 15px;
    padding: 1.5rem;
  }

  .answer-container.active {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    animation: slideInUp 0.5s ease;
  }

  @keyframes slideInUp {
    from {
      transform: translateY(50px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .answer-input {
    width: 90%;
    max-width: 500px;
    padding: 1.2rem;
    font-size: 1.5rem;
    background: rgba(0, 0, 0, 0.7);
    border: 3px solid var(--accent-blue);
    border-radius: 10px;
    color: var(--text-light);
    text-align: center;
    margin: 0 auto 1rem auto;
    display: block;
  }

  .answer-input:focus {
    outline: none;
    border-color: var(--primary-gold);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
  }

  /* Multiple Choice Buttons */
  .choice-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-top: 1rem;
  }

  .choice-button {
    background: linear-gradient(135deg, rgba(0, 100, 200, 0.8), rgba(0, 50, 150, 0.9));
    color: var(--text-light);
    border: 2px solid var(--accent-blue);
    border-radius: 15px;
    padding: 1rem 1.5rem;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all var(--animation-speed) ease;
    text-align: left;
    min-height: 60px;
    display: flex;
    align-items: center;
  }

  .choice-button:hover:not(:disabled) {
    background: linear-gradient(135deg, rgba(0, 120, 220, 0.9), rgba(0, 80, 180, 1));
    border-color: var(--primary-gold);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 100, 200, 0.4);
  }

  .choice-button:active {
    transform: translateY(0);
  }

  .choice-button.selected {
    background: linear-gradient(135deg, var(--success-green), #00CC70);
    border-color: var(--primary-gold);
    color: var(--dark-bg);
    font-weight: 700;
  }

  .choice-button:disabled {
    background: rgba(100, 100, 100, 0.5);
    cursor: not-allowed;
    opacity: 0.5;
  }

  .submit-button {
    background: linear-gradient(135deg, var(--success-green), #00CC70);
    color: var(--dark-bg);
    border: none;
    border-radius: 50px;
    padding: 1rem 3rem;
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    transition: all var(--animation-speed) ease;
    display: inline-block;
    margin: 0 auto;
  }

  .submit-button:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
  }

  .submit-button:disabled {
    background: rgba(100, 100, 100, 0.5);
    cursor: not-allowed;
    opacity: 0.5;
  }

  /* Daily Double Modal */
  .daily-double-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(0, 0, 0, 0.95));
    z-index: 10000;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(10px);
  }

  .daily-double-modal.active {
    display: flex;
  }

  .daily-double-content {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(32, 32, 64, 0.9));
    border: 3px solid var(--primary-gold);
    border-radius: 20px;
    padding: 3rem;
    text-align: center;
    animation: dailyDoubleAppear 0.5s ease-out;
  }

  .daily-double-title {
    font-size: 3rem;
    color: var(--primary-gold);
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    margin-bottom: 2rem;
    animation: pulse 2s ease-in-out infinite;
  }

  .wager-info {
    color: var(--text-dim);
    font-size: 1.2rem;
    margin-bottom: 1rem;
  }

  @keyframes dailyDoubleAppear {
    from {
      opacity: 0;
      transform: scale(0.8);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

/* Final Round */
  .final-round-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a1a2e, #0a0a0f);
    z-index: 1000;
  }

  .final-round-modal.active {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .final-title {
    font-family: 'Orbitron', monospace;
    font-size: 3rem;
    font-weight: 900;
    background: linear-gradient(45deg, var(--primary-gold), var(--secondary-gold));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 2rem;
    animation: finalPulse 2s ease-in-out infinite;
  }

  @keyframes finalPulse {
    0%, 100% { transform: scale(1); text-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
    50% { transform: scale(1.05); text-shadow: 0 0 50px rgba(255, 215, 0, 0.8); }
  }

  .wager-container {
    background: var(--card-bg);
    border: 3px solid var(--primary-gold);
    border-radius: 20px;
    padding: 2rem;
    margin-bottom: 2rem;
  }

  .wager-input {
    width: 300px;
    padding: 1rem;
    font-size: 1.5rem;
    font-family: 'Orbitron', monospace;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid var(--accent-blue);
    border-radius: 10px;
    color: var(--primary-gold);
    text-align: center;
  }

  /* Messages */
  .message-overlay {
    display: none;
    position: fixed;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, rgba(20, 20, 30, 0.98), rgba(40, 40, 60, 0.98));
    border: 3px solid var(--primary-gold);
    border-radius: 20px;
    padding: 3rem 4rem;
    z-index: 2000;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9), 0 0 40px rgba(255, 215, 0, 0.4);
  }

  .message-overlay.active {
    display: block;
    animation: bounceIn 0.5s ease;
  }

  @keyframes bounceIn {
    0% { transform: translate(-50%, -50%) scale(0); }
    70% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
  }

  .message-text {
    font-size: 2.5rem;
    font-weight: 900;
    color: var(--text-light);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    font-family: 'Orbitron', monospace;
    letter-spacing: 0.05em;
  }

  .message-overlay.correct .message-text {
    color: var(--success-green);
    text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
  }

  .message-overlay.incorrect .message-text {
    color: var(--error-red);
    text-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
  }

  .message-overlay.success .message-text {
    color: var(--success-green);
    text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
  }

  .message-overlay.warning .message-text {
    color: var(--secondary-gold);
    text-shadow: 0 0 20px rgba(255, 165, 0, 0.6);
  }

  /* Chat/Activity Feed */
  .activity-feed {
    position: fixed;
    right: 1rem;
    bottom: 0.25rem;
    width: 260px;
    max-height: 120px;
    background: rgba(20, 20, 30, 0.95);
    border: 2px solid rgba(255, 215, 0, 0.3);
    border-radius: 8px;
    padding: 0.6rem;
    overflow-y: auto;
    z-index: 100;
  }

  .activity-title {
    font-weight: 700;
    color: var(--primary-gold);
    margin-bottom: 1rem;
    text-align: center;
    text-transform: uppercase;
  }

  .activity-item {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    font-size: 0.9rem;
    color: var(--text-dim);
    animation: slideInRight 0.3s ease;
  }

  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  .activity-item .player-name {
    color: var(--accent-blue);
    font-weight: 600;
  }

  .activity-item .points {
    color: var(--primary-gold);
    font-weight: 700;
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .game-board {
      grid-template-columns: repeat(3, 1fr);
    }

    .clue-cell {
      font-size: 1.5rem;
    }

    .players-container {
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .player-card {
      min-width: 100px;
    }

    .activity-feed {
      display: none;
    }
  }

  /* Tablet and smaller desktop - make activity feed more compact */
  @media (max-width: 1200px) {
    .activity-feed {
      width: 200px;
      max-height: 100px;
      padding: 0.5rem;
      font-size: 0.8rem;
      bottom: 0.2rem;
    }

    .activity-title {
      font-size: 0.85rem;
      margin-bottom: 0.4rem;
    }

    .activity-item {
      padding: 0.25rem;
      margin-bottom: 0.25rem;
      font-size: 0.75rem;
    }
  }
</style>

<div class="game-container">
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="game-logo">
      <span class="logo-text">BUZZCHAIN</span>
    </div>
    <div class="round-info">
      <div class="round-label">Current Round</div>
      <div class="round-name" id="roundName">ROUND 1</div>
    </div>
    <div class="picker-info" style="flex: 1; text-align: center; color: var(--accent-yellow);">
      <div class="picker-label" style="font-size: 0.8rem; opacity: 0.8;">Current Picker</div>
      <div class="picker-name" id="currentPickerName" style="font-size: 1.2rem; font-weight: bold;">---</div>
    </div>
    <div class="timer" id="gameTimer">--:--</div>
  </div>

  <!-- Game Board -->
  <div class="board-section">
    <div class="game-board" id="gameBoard">
      <!-- Categories and clues will be dynamically inserted here -->
    </div>
  </div>

  <!-- Players Section -->
  <div class="players-section">
    <div class="players-container" id="playersContainer">
      <!-- Player cards will be dynamically inserted here -->
    </div>
  </div>
</div>

<!-- Question Modal -->
<div class="question-modal" id="questionModal">
  <div class="question-content">
    <div class="question-value" id="questionValue">$0</div>
    <div class="question-category" id="questionCategory">CATEGORY</div>
    <div class="question-text" id="questionText">Question will appear here</div>
    <div class="question-timer" id="questionTimer">30</div>

    <div class="buzz-container" id="buzzContainer">
      <button class="buzz-button" id="buzzButton">BUZZ!</button>
    </div>

    <div class="answer-container" id="answerContainer">
      <h3 style="color: var(--success-green); margin-bottom: 1rem; font-size: 1.2rem;">üéØ YOU BUZZED IN! CHOOSE YOUR ANSWER:</h3>
      <div class="choice-buttons" id="choiceButtons">
        <button class="choice-button" id="choiceA" data-choice="0">A. Choice A</button>
        <button class="choice-button" id="choiceB" data-choice="1">B. Choice B</button>
        <button class="choice-button" id="choiceC" data-choice="2">C. Choice C</button>
        <button class="choice-button" id="choiceD" data-choice="3">D. Choice D</button>
      </div>
    </div>
  </div>
</div>

<!-- Daily Double Modal -->
<div class="daily-double-modal" id="dailyDoubleModal" style="display: none;">
  <div class="daily-double-content">
    <h1 class="daily-double-title">üèÜ DAILY DOUBLE! üèÜ</h1>
    <div class="wager-container">
      <h2 style="color: var(--text-dim); margin-bottom: 1rem;">Enter Your Wager</h2>
      <p class="wager-info" id="dailyDoubleInfo">Maximum wager: $0</p>
      <input type="number" class="wager-input" id="dailyDoubleWagerInput" placeholder="$0" min="0" />
      <button class="submit-button" id="submitDailyDoubleWager" style="margin-top: 1rem;">Lock In Wager</button>
    </div>
  </div>
</div>

<!-- Final Round Modal -->
<div class="final-round-modal" id="finalModal">
  <h1 class="final-title">FINAL ROUND</h1>
  <div class="wager-container">
    <h2 style="color: var(--text-dim); margin-bottom: 1rem;">Enter Your Wager</h2>
    <input type="number" class="wager-input" id="wagerInput" placeholder="$0" min="0" />
    <button class="submit-button" id="submitWager" style="margin-top: 1rem;">Lock In Wager</button>
  </div>
  <div class="question-content" id="finalQuestion" style="display: none;">
    <div class="question-category" id="finalCategory">CATEGORY</div>
    <div class="question-text" id="finalClue">Final Round clue will appear here</div>
    <div class="answer-container active">
      <input type="text" class="answer-input" id="finalAnswer" placeholder="What is your answer?" />
      <button class="submit-button" id="submitFinalAnswer">Submit Final Answer</button>
    </div>
  </div>
</div>

<!-- Message Overlay -->
<div class="message-overlay" id="messageOverlay">
  <div class="message-text" id="messageText"></div>
</div>

<!-- Activity Feed -->
<div class="activity-feed" id="activityFeed">
  <div class="activity-title">Game Activity</div>
  <div id="activityItems"></div>
</div>

<script>
// Game State
let gameState = {
  phase: 'LOBBY',
  round: 1,
  categories: [],
  board: [],
  players: {},
  currentPlayer: null,
  currentQuestion: null,
  buzzerActive: false,
  timeRemaining: 0,
  timerInterval: null,
  questionStartTime: 0,
  questionDuration: 10000,
  modalCloseTimeout: null
};

// Store the current player ID globally
let currentPlayerId = null;

// Initialize game when ready
function initializeGame() {
  if (typeof hytopia === 'undefined') {
    console.error('HYTOPIA API not available! Waiting...');
    setTimeout(initializeGame, 100);
    return;
  }

  console.log('üéÆ Buzzchain Game Board Initialized');

  // Store player ID if available
  if (hytopia.playerId) {
    currentPlayerId = hytopia.playerId;
    console.log('üÜî Current Player ID set:', currentPlayerId);
  }

  setupEventListeners();

  // Listen for game updates from server
  hytopia.onData(handleServerMessage);

  // Request initial game state
  hytopia.sendData({
    type: 'GET_GAME_STATE'
  });
}

// Handle messages from server
function handleServerMessage(data) {
  console.log('Received from server:', data);

  switch(data.type) {
    case 'PLAYER_ID':
      currentPlayerId = data.payload.playerId || data.payload;
      console.log('üÜî Player ID received:', currentPlayerId);
      break;
    case 'GAME_STATE':
      console.log('Received GAME_STATE:', data.payload);
      updateGameState(data.payload.gameState || data.payload);
      break;
    case 'BOARD_UPDATE':
      updateBoard(data.payload);
      break;
    case 'QUESTION_START':
    case 'CLUE_REVEAL':
      console.log('Received CLUE_REVEAL:', data.payload);
      showQuestion(data.payload);
      break;
    case 'DAILY_DOUBLE_REVEAL':
      console.log('Received DAILY_DOUBLE_REVEAL:', data.payload);
      showDailyDoubleWager(data.payload);
      break;
    case 'BUZZ_RESULT':
      handleBuzzWinner(data.payload);
      break;
    case 'JUDGE':
      showAnswerResult(data.payload);
      break;
    case 'PLAYER_UPDATE':
      updatePlayers(data.payload);
      break;
    case 'ROUND_CHANGE':
      handleRoundChange(data.payload);
      break;
    case 'FINAL_ROUND':
      showFinalRound(data.payload);
      break;
    case 'GAME_END':
      showGameEnd(data.payload);
      break;
    case 'ACTIVITY':
      addActivity(data.payload);
      break;
  }
}

// Update game state
function updateGameState(state) {
  console.log('updateGameState called with:', state);
  console.log('state.currentClue:', state.currentClue);
  console.log('Current question modal state:', gameState.currentQuestion ? 'OPEN' : 'CLOSED');

  // Preserve local timer state when updating from server
  const localTimeRemaining = gameState.timeRemaining;
  const localTimerInterval = gameState.timerInterval;

  gameState = { ...gameState, ...state };

  // Restore local timer state if we have an active timer
  if (localTimerInterval && localTimeRemaining > 0) {
    gameState.timeRemaining = localTimeRemaining;
    gameState.timerInterval = localTimerInterval;
    console.log(`üîß Preserved local timer state: ${localTimeRemaining} seconds remaining`);
  }

  // Update UI based on state
  updateRoundDisplay();
  updateCurrentPicker(state);

  // Merge usedCells into board data before updating
  if (state.board && state.usedCells) {
    const boardWithUsedCells = JSON.parse(JSON.stringify(state.board)); // Deep copy
    state.usedCells.forEach(cellStr => {
      const [cat, idx] = cellStr.split('-').map(Number);
      if (boardWithUsedCells.categories[cat] && boardWithUsedCells.categories[cat].clues[idx]) {
        boardWithUsedCells.categories[cat].clues[idx].answered = true;
      }
    });
    updateBoard(boardWithUsedCells);
  } else if (state.board) {
    updateBoard(state.board);
  }

  updatePlayers(state.players);

  if (state.phase === 'FINAL') {
    showFinalRound();
  }
}

// Update round display
function updateRoundDisplay() {
  const roundName = document.getElementById('roundName');
  if (gameState.phase === 'FINAL') {
    roundName.textContent = 'FINAL ROUND';
  } else {
    roundName.textContent = `ROUND ${gameState.round}`;
  }
}

// Update current picker display
function updateCurrentPicker(state) {
  const pickerNameElement = document.getElementById('currentPickerName');
  if (!pickerNameElement) return;

  if (state.currentPickerId) {
    // Find the picker's name from the players list
    const picker = state.players?.find(p => p.id === state.currentPickerId);
    if (picker) {
      pickerNameElement.textContent = picker.name;
      pickerNameElement.style.color = 'var(--accent-yellow)';

      // Add animation for emphasis when it's the human player's turn
      if (state.currentPickerId === currentPlayerId) {
        pickerNameElement.style.animation = 'pulse 1s ease-in-out infinite';
        pickerNameElement.textContent = `‚≠ê ${picker.name} ‚≠ê`;
      } else {
        pickerNameElement.style.animation = 'none';
      }
    } else {
      pickerNameElement.textContent = '---';
    }
  } else {
    pickerNameElement.textContent = 'Waiting...';
  }
}

// Update game board
function updateBoard(boardData) {
  const boardElement = document.getElementById('gameBoard');
  boardElement.innerHTML = '';

  if (!boardData || !boardData.categories) {
    console.error('No board data available');
    return;
  }

  // Add category headers
  boardData.categories.forEach(category => {
    const header = document.createElement('div');
    header.className = 'category-header';
    header.textContent = category.name;
    boardElement.appendChild(header);
  });

  // Add clue cells
  for (let row = 0; row < 5; row++) {
    for (let col = 0; col < boardData.categories.length; col++) {
      const clue = boardData.categories[col].clues[row];
      const cell = document.createElement('div');
      cell.className = 'clue-cell';

      if (clue.answered) {
        cell.classList.add('answered');
      }

      if (clue.isDailyDouble) {
        cell.classList.add('daily-double');
      }

      cell.textContent = clue.answered ? '' : `$${clue.value}`;
      cell.dataset.category = col;
      cell.dataset.clue = row;

      if (!clue.answered) {
        cell.addEventListener('click', () => selectClue(col, row));
      }

      boardElement.appendChild(cell);
    }
  }
}

// Update players display
function updatePlayers(playersData) {
  const container = document.getElementById('playersContainer');
  container.innerHTML = '';

  if (!playersData) return;

  Object.values(playersData).forEach(player => {
    const card = document.createElement('div');
    card.className = 'player-card';

    if (player.id === (gameState.currentPlayer || gameState.currentPickerId)) {
      card.classList.add('current-turn');
    }

    if (player.hasBuzzed) {
      card.classList.add('buzzer-winner');
    }

    card.dataset.playerId = player.id;
    card.innerHTML = `
      <div class="player-name">${player.name}</div>
      <div class="player-score ${player.score < 0 ? 'negative' : ''}">
        $${player.score.toLocaleString()}
      </div>
      <div class="player-indicator">
        ${player.id === gameState.currentPlayer ? '‚ñ∂ YOUR TURN' : ''}
        ${player.hasBuzzed ? 'üîî BUZZED' : ''}
      </div>
    `;

    container.appendChild(card);
  });
}

// Select a clue
function selectClue(categoryIndex, clueIndex) {
  if (gameState.currentQuestion) return;

  // Play clue selection sound
  hytopia.sendData({
    type: 'PLAY_SOUND',
    payload: { sound: 'click' }
  });

  hytopia.sendData({
    type: 'SELECT_CELL',
    payload: {
      categoryIndex,
      clueIndex
    }
  });
}

// Show question modal
function showQuestion(questionData) {
  console.log('showQuestion called with data:', questionData);
  console.log('questionData.timeLimit:', questionData.timeLimit);

  // Play question reveal sound
  hytopia.sendData({
    type: 'PLAY_SOUND',
    payload: { sound: 'transition' }
  });

  gameState.currentQuestion = questionData;
  gameState.questionStartTime = Date.now();
  gameState.questionDuration = (questionData.timeLimit || 20) * 1000; // Convert to milliseconds

  const modal = document.getElementById('questionModal');
  const valueEl = document.getElementById('questionValue');
  const categoryEl = document.getElementById('questionCategory');
  const textEl = document.getElementById('questionText');
  const timerEl = document.getElementById('questionTimer');
  const buzzContainer = document.getElementById('buzzContainer');
  const answerContainer = document.getElementById('answerContainer');

  // Set question content
  valueEl.textContent = questionData.isDailyDouble ? 'DAILY DOUBLE!' : `$${questionData.value}`;
  categoryEl.textContent = questionData.category;
  textEl.textContent = questionData.clue || questionData.text; // Handle both field names

  // Populate multiple choice options
  console.log('Question data received:', questionData);
  console.log('Choices:', questionData.choices);
  console.log('Correct choice:', questionData.correctChoice);

  if (questionData.choices && questionData.choices.length === 4) {
    console.log('Populating choice buttons with:', questionData.choices);
    const choiceButtons = ['choiceA', 'choiceB', 'choiceC', 'choiceD'];
    choiceButtons.forEach((buttonId, index) => {
      const button = document.getElementById(buttonId);
      if (button) {
        const letter = String.fromCharCode(65 + index); // A, B, C, D
        button.textContent = `${letter}. ${questionData.choices[index]}`;
        button.disabled = false;
        button.classList.remove('selected');
        console.log(`Set button ${buttonId} to: ${button.textContent}`);
      }
    });
  } else {
    console.warn('No choices found or incorrect number of choices:', questionData.choices);
  }

  // Reset UI state
  buzzContainer.style.display = questionData.isDailyDouble ? 'none' : 'block';
  answerContainer.classList.remove('active');
  answerContainer.style.display = 'none'; // Ensure it's hidden initially
  document.getElementById('buzzButton').disabled = false;
  resetChoiceButtons();

  // Show modal
  modal.classList.add('active');

  // Start timer (ensure minimum 20 seconds for human players)
  const timerSeconds = Math.max(questionData.timeLimit || 20, 20);
  console.log(`Using timer duration: ${timerSeconds} seconds`);
  startQuestionTimer(timerSeconds);

  // If Daily Double and this player is the picker, show answer choices immediately
  // (Wager should have been handled separately via DAILY_DOUBLE_REVEAL event)
  if (questionData.isDailyDouble && questionData.pickerId === currentPlayerId) {
    answerContainer.classList.add('active');
    answerContainer.style.display = 'block';
  }
}

// Reset choice buttons to default state
function resetChoiceButtons() {
  const choiceButtons = ['choiceA', 'choiceB', 'choiceC', 'choiceD'];
  choiceButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.classList.remove('selected');
      button.disabled = false;
    }
  });
}

// Handle choice button selection
function selectChoice(choiceIndex) {
  console.log('Choice selected:', choiceIndex);

  // Remove previous selection
  resetChoiceButtons();

  // Mark selected choice
  const choiceButtons = ['choiceA', 'choiceB', 'choiceC', 'choiceD'];
  const selectedButton = document.getElementById(choiceButtons[choiceIndex]);
  if (selectedButton) {
    selectedButton.classList.add('selected');
  }

  // Submit answer immediately
  submitChoice(choiceIndex);
}

// Submit choice answer
function submitChoice(choiceIndex) {
  console.log('Submitting choice:', choiceIndex);

  if (choiceIndex < 0 || choiceIndex > 3) {
    showMessage('Invalid choice selection!', 'warning');
    return;
  }

  // Disable all choice buttons
  const choiceButtons = ['choiceA', 'choiceB', 'choiceC', 'choiceD'];
  choiceButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) button.disabled = true;
  });

  // Get the text of the selected choice for display purposes
  const selectedButton = document.getElementById(choiceButtons[choiceIndex]);
  const selectedText = selectedButton ? selectedButton.textContent : `Choice ${choiceIndex + 1}`;

  hytopia.sendData({
    type: 'ANSWER_SUBMIT',
    payload: {
      answer: selectedText, // For logging/display
      choiceIndex: choiceIndex,
      submitTime: Date.now()
    }
  });

  showMessage(`Answer submitted: ${selectedText}`, 'success');
}

// Start question timer
function startQuestionTimer(seconds) {
  console.log(`üïê Starting question timer with ${seconds} seconds`);
  gameState.timeRemaining = seconds;
  const timerEl = document.getElementById('questionTimer');

  clearInterval(gameState.timerInterval);

  gameState.timerInterval = setInterval(() => {
    console.log(`‚è∞ Timer tick: ${gameState.timeRemaining} seconds remaining`);

    if (gameState.timeRemaining <= 0) {
      console.log(`‚è∞ Timer expired! Closing question modal`);
      clearInterval(gameState.timerInterval);
      closeQuestionModal();
      return;
    }

    gameState.timeRemaining--;
    timerEl.textContent = gameState.timeRemaining;

    // Add warning classes
    timerEl.classList.remove('warning', 'danger');
    if (gameState.timeRemaining <= 3) {
      timerEl.classList.add('danger');
    } else if (gameState.timeRemaining <= 5) {
      timerEl.classList.add('warning');
    }
  }, 1000);
}

// Handle buzz button
function buzz() {
  if (gameState.buzzerActive) return;

  gameState.buzzerActive = true;
  const buzzButton = document.getElementById('buzzButton');
  buzzButton.disabled = true;
  buzzButton.style.opacity = '0.3';

  console.log('Buzzing in!');

  hytopia.sendData({
    type: 'BUZZ',
    payload: {
      timestamp: Date.now()
    }
  });

  // Smart fallback for legitimate buzz wins (more conservative approach)
  setTimeout(() => {
    const answerContainer = document.getElementById('answerContainer');
    if (answerContainer && !answerContainer.classList.contains('active')) {
      console.log('‚ö†Ô∏è Server response delayed - offering manual activation');

      // Create a manual activation button
      const fallbackButton = document.createElement('button');
      fallbackButton.id = 'fallbackAnswerButton';
      fallbackButton.textContent = 'üéØ I buzzed in first - Show answer input';
      fallbackButton.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ff6b35;
        color: white;
        border: none;
        padding: 1rem 2rem;
        border-radius: 8px;
        font-size: 1.2rem;
        cursor: pointer;
        z-index: 9999;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      `;

      fallbackButton.onclick = () => {
        console.log('üîß Manual activation triggered by user');
        answerContainer.classList.add('active');
        answerContainer.style.display = 'block';
        answerContainer.style.visibility = 'visible';
        answerContainer.style.opacity = '1';

        const answerInput = document.getElementById('answerInput');
        if (answerInput) {
          answerInput.focus();
          setupAnswerInputFocusProtection(answerInput);
        }

        fallbackButton.remove();
        showMessage('üéØ Answer input activated manually!', 'success');
      };

      document.body.appendChild(fallbackButton);

      // Auto-remove button after 10 seconds
      setTimeout(() => {
        if (fallbackButton.parentNode) {
          fallbackButton.remove();
        }
      }, 10000);
    }
  }, 3000);
}

// Handle buzz winner
function handleBuzzWinner(data) {
  console.log('üéØ Buzz winner received:', data);
  console.log('üÜî Player ID comparison:', {
    dataWinnerId: data.winnerId,
    currentPlayerId: currentPlayerId,
    hytopiaPlayerId: hytopia.playerId,
    match: data.winnerId === currentPlayerId || data.winnerId === hytopia.playerId
  });

  if (!data || !data.winnerId) {
    console.error('Invalid buzz winner data:', data);
    return;
  }

  // Play appropriate sound effect
  hytopia.sendData({
    type: 'PLAY_SOUND',
    payload: { sound: 'buzz' }
  });

  if (data.winnerId === currentPlayerId || data.winnerId === hytopia.playerId) {
    // Show answer choices
    const answerContainer = document.getElementById('answerContainer');

    console.log('Showing answer container for player buzz win');

    // Make sure container exists and is shown
    if (answerContainer) {
      console.log('Answer container before activation:', {
        display: window.getComputedStyle(answerContainer).display,
        visibility: window.getComputedStyle(answerContainer).visibility,
        opacity: window.getComputedStyle(answerContainer).opacity,
        classList: answerContainer.classList.toString()
      });

      // Force show the container with multiple methods
      answerContainer.classList.add('active');
      answerContainer.style.display = 'block';
      answerContainer.style.visibility = 'visible';
      answerContainer.style.opacity = '1';
      answerContainer.style.zIndex = '1001';

      // Reset choice buttons to enabled state
      resetChoiceButtons();

      console.log('Answer container after activation:', {
        display: window.getComputedStyle(answerContainer).display,
        visibility: window.getComputedStyle(answerContainer).visibility,
        opacity: window.getComputedStyle(answerContainer).opacity,
        classList: answerContainer.classList.toString()
      });
    } else {
      console.error('Answer container not found!');
    }

    showMessage('üéØ YOU BUZZED IN FIRST! Choose your answer!', 'success');

    // Visual feedback - flash the screen green briefly
    document.body.style.animation = 'flashGreen 0.5s ease';
    setTimeout(() => {
      document.body.style.animation = '';
    }, 500);

    // Update player card to show buzz winner
    const playerCards = document.querySelectorAll('.player-card');
    playerCards.forEach(card => {
      if (card.dataset.playerId === data.winnerId) {
        card.classList.add('buzzer-winner');
      }
    });
  } else {
    // Show who buzzed
    showMessage(`‚ö° ${data.winnerName} buzzed in first!`, 'warning');
    document.getElementById('buzzButton').disabled = true;
    console.log('üö´ Different player won the buzz:', {
      winner: data.winnerName,
      winnerId: data.winnerId,
      currentPlayer: hytopia.playerId
    });

    // Visual feedback - flash the screen red briefly
    document.body.style.animation = 'flashRed 0.3s ease';
    setTimeout(() => {
      document.body.style.animation = '';
    }, 300);

    // Update player card to show who buzzed
    const playerCards = document.querySelectorAll('.player-card');
    playerCards.forEach(card => {
      if (card.dataset.playerId === data.winnerId) {
        card.classList.add('buzzer-winner');
      }
    });
  }

  // Add to activity feed
  addActivity({
    text: `${data.winnerName} buzzed in! (${Math.round(data.buzzTime)}ms)`,
    type: 'buzz'
  });
}

// Focus protection for answer input to prevent HYTOPIA chat interference
function setupAnswerInputFocusProtection(answerInput) {
  console.log('Setting up focus protection for answer input');

  // Remove any existing protection
  if (window.answerInputFocusInterval) {
    clearInterval(window.answerInputFocusInterval);
  }

  // More reasonable focus maintenance - check every 500ms
  let focusAttempts = 0;
  window.answerInputFocusInterval = setInterval(() => {
    if (answerInput && document.activeElement !== answerInput) {
      focusAttempts++;
      // Only log and refocus a few times to avoid spam
      if (focusAttempts <= 5) {
        console.log('Refocusing answer input (attempt ' + focusAttempts + ')');
        answerInput.focus();
      } else {
        // Stop trying after 5 attempts
        clearInterval(window.answerInputFocusInterval);
        window.answerInputFocusInterval = null;
      }
    }
  }, 500);

  // Prevent HYTOPIA chat from capturing keydown events
  const keydownHandler = (e) => {
    // Stop event from bubbling to HYTOPIA chat
    e.stopImmediatePropagation();
    console.log('Answer input keydown:', e.key);
  };

  const keypressHandler = (e) => {
    // Stop event from bubbling to HYTOPIA chat
    e.stopImmediatePropagation();
    console.log('Answer input keypress:', e.key);
  };

  const inputHandler = (e) => {
    // Stop event from bubbling to HYTOPIA chat
    e.stopImmediatePropagation();
    console.log('Answer input changed:', e.target.value);
  };

  // Add protected event listeners
  answerInput.addEventListener('keydown', keydownHandler, true);
  answerInput.addEventListener('keypress', keypressHandler, true);
  answerInput.addEventListener('input', inputHandler, true);

  // Store cleanup function
  answerInput._cleanupFocusProtection = () => {
    console.log('Cleaning up answer input focus protection');
    if (window.answerInputFocusInterval) {
      clearInterval(window.answerInputFocusInterval);
      window.answerInputFocusInterval = null;
    }
    answerInput.removeEventListener('keydown', keydownHandler, true);
    answerInput.removeEventListener('keypress', keypressHandler, true);
    answerInput.removeEventListener('input', inputHandler, true);
  };

  // Also prevent document-level key events from reaching HYTOPIA chat
  const documentKeyHandler = (e) => {
    if (document.activeElement === answerInput) {
      e.stopImmediatePropagation();
      e.stopPropagation();
    }
  };

  document.addEventListener('keydown', documentKeyHandler, true);
  document.addEventListener('keypress', documentKeyHandler, true);

  // Clean up document handlers when input is cleaned up
  const originalCleanup = answerInput._cleanupFocusProtection;
  answerInput._cleanupFocusProtection = () => {
    originalCleanup();
    document.removeEventListener('keydown', documentKeyHandler, true);
    document.removeEventListener('keypress', documentKeyHandler, true);
  };
}

// Clean up answer input focus protection
function cleanupAnswerInputFocusProtection() {
  const answerInput = document.getElementById('answerInput');
  if (answerInput && answerInput._cleanupFocusProtection) {
    answerInput._cleanupFocusProtection();
  }

  const finalAnswer = document.getElementById('finalAnswer');
  if (finalAnswer && finalAnswer._cleanupFocusProtection) {
    finalAnswer._cleanupFocusProtection();
  }
}

// Submit answer
function submitAnswer() {
  const answerInput = document.getElementById('answerInput');
  const answer = answerInput ? answerInput.value.trim() : '';

  console.log('Submitting answer:', answer);

  if (!answer) {
    showMessage('Please type an answer!', 'warning');
    return;
  }

  // Play answer submit sound
  hytopia.sendData({
    type: 'PLAY_SOUND',
    payload: { sound: 'confirm' }
  });

  hytopia.sendData({
    type: 'ANSWER_SUBMIT',
    payload: { answer }
  });

  // Clean up focus protection after submitting answer
  cleanupAnswerInputFocusProtection();

  const submitButton = document.getElementById('submitButton');
  if (submitButton) {
    submitButton.disabled = true;
    submitButton.textContent = 'Submitted...';
  }
}

// Show answer result
function showAnswerResult(result) {
  const messageClass = result.correct ? 'correct' : 'incorrect';
  const message = result.correct
    ? `‚úÖ CORRECT! +$${result.scoreChange || result.points}`
    : `‚ùå INCORRECT! -$${Math.abs(result.scoreChange || result.points)}`;

  // Play appropriate sound for correct/incorrect
  const soundEffect = result.correct ? 'correct' : 'incorrect';
  hytopia.sendData({
    type: 'PLAY_SOUND',
    payload: { sound: soundEffect }
  });

  showMessage(message, messageClass);

  // Add to activity feed
  addActivity({
    text: `${result.playerName} ${result.correct ? 'got' : 'missed'} for $${Math.abs(result.scoreChange || result.points)}`,
    type: result.correct ? 'correct' : 'incorrect'
  });

  // Clear any existing modal close timeout
  if (gameState.modalCloseTimeout) {
    clearTimeout(gameState.modalCloseTimeout);
  }

  // If correct answer, close modal quickly to move to next question
  // If incorrect, wait for the full timer to allow other players to buzz
  if (result.correct) {
    // Close modal after short delay (1.5 seconds) for correct answers
    console.log('Correct answer - closing modal quickly');
    gameState.modalCloseTimeout = setTimeout(() => {
      closeQuestionModal();
    }, 1500);
  } else {
    // For incorrect answers, respect the full question timer
    const elapsed = Date.now() - gameState.questionStartTime;
    const remaining = gameState.questionDuration - elapsed;

    if (remaining > 0) {
      // Question timer is still running - wait for it to complete
      console.log(`Incorrect answer, waiting ${remaining}ms more for question timer to complete`);
      gameState.modalCloseTimeout = setTimeout(() => {
        closeQuestionModal();
      }, remaining);
    } else {
      // Question timer already expired - close immediately
      closeQuestionModal();
    }
  }
}

// Close question modal
function closeQuestionModal() {
  console.log('üö® closeQuestionModal() called!');
  console.trace('Call stack:');

  clearInterval(gameState.timerInterval);

  // Clear modal close timeout if it exists
  if (gameState.modalCloseTimeout) {
    clearTimeout(gameState.modalCloseTimeout);
    gameState.modalCloseTimeout = null;
  }

  document.getElementById('questionModal').classList.remove('active');
  gameState.currentQuestion = null;
  gameState.buzzerActive = false;

  // Clean up focus protection when modal closes
  cleanupAnswerInputFocusProtection();
}

// Show Final Round
function showFinalRound(data) {
  const modal = document.getElementById('finalModal');
  modal.classList.add('active');

  if (data && data.category) {
    // Show the question
    document.getElementById('finalCategory').textContent = data.category;
    document.getElementById('finalClue').textContent = data.clue;
    document.querySelector('.wager-container').style.display = 'none';
    document.getElementById('finalQuestion').style.display = 'block';

    // Set up focus protection for Final Round answer input
    const finalAnswer = document.getElementById('finalAnswer');
    if (finalAnswer) {
      finalAnswer.focus();
      setupAnswerInputFocusProtection(finalAnswer);
    }
  }
}

// Show Daily Double wager selection
function showDailyDoubleWager(data) {
  console.log('Showing Daily Double wager screen:', data);

  // Only show wager modal to the picker
  if (data.pickerId === currentPlayerId) {
    const modal = document.getElementById('dailyDoubleModal');
    const infoElement = document.getElementById('dailyDoubleInfo');
    const wagerInput = document.getElementById('dailyDoubleWagerInput');

    // Set maximum wager info
    infoElement.textContent = `Maximum wager: $${data.maxWager || 1000}`;
    wagerInput.max = data.maxWager || 1000;
    wagerInput.value = '';

    // Show modal
    modal.classList.add('active');
    wagerInput.focus();
  }
}

// Submit Daily Double wager
function submitDailyDoubleWager() {
  const wager = parseInt(document.getElementById('dailyDoubleWagerInput').value) || 0;
  const maxWager = parseInt(document.getElementById('dailyDoubleWagerInput').max) || 1000;

  if (wager < 0 || wager > maxWager) {
    alert(`Invalid wager. Please enter a value between $0 and $${maxWager}.`);
    return;
  }

  console.log(`Submitting Daily Double wager: $${wager}`);

  hytopia.sendData({
    type: 'DAILY_DOUBLE_WAGER',
    payload: { wager }
  });

  // Hide wager modal
  document.getElementById('dailyDoubleModal').classList.remove('active');
  document.getElementById('submitDailyDoubleWager').disabled = true;
}

// Submit wager
function submitWager() {
  const wager = parseInt(document.getElementById('wagerInput').value) || 0;

  hytopia.sendData({
    type: 'FINAL_WAGER',
    payload: { wager }
  });

  document.getElementById('submitWager').disabled = true;
}

// Submit final answer
function submitFinalAnswer() {
  const answer = document.getElementById('finalAnswer').value.trim();

  hytopia.sendData({
    type: 'FINAL_ANSWER',
    payload: { answer }
  });

  // Clean up focus protection after submitting final answer
  cleanupAnswerInputFocusProtection();

  document.getElementById('submitFinalAnswer').disabled = true;
}

// Show message overlay
function showMessage(text, type = 'info') {
  const overlay = document.getElementById('messageOverlay');
  const textEl = document.getElementById('messageText');

  // Clear any existing timeout
  if (window.messageTimeout) {
    clearTimeout(window.messageTimeout);
  }

  overlay.className = `message-overlay active ${type}`;
  textEl.textContent = text;

  // Keep message visible longer for important notifications
  const duration = (type === 'success' || type === 'warning') ? 4000 : 3000;

  window.messageTimeout = setTimeout(() => {
    overlay.classList.remove('active');
  }, duration);
}

// Add activity to feed
function addActivity(activity) {
  const container = document.getElementById('activityItems');
  const item = document.createElement('div');
  item.className = 'activity-item';
  item.innerHTML = activity.text;

  container.insertBefore(item, container.firstChild);

  // Keep only last 10 items
  while (container.children.length > 10) {
    container.removeChild(container.lastChild);
  }
}

// Setup event listeners
function setupEventListeners() {
  document.getElementById('buzzButton').addEventListener('click', buzz);
  document.getElementById('submitWager').addEventListener('click', submitWager);
  document.getElementById('submitDailyDoubleWager').addEventListener('click', submitDailyDoubleWager);
  document.getElementById('submitFinalAnswer').addEventListener('click', submitFinalAnswer);

  // Choice button event listeners
  document.getElementById('choiceA').addEventListener('click', () => selectChoice(0));
  document.getElementById('choiceB').addEventListener('click', () => selectChoice(1));
  document.getElementById('choiceC').addEventListener('click', () => selectChoice(2));
  document.getElementById('choiceD').addEventListener('click', () => selectChoice(3));

  // Keyboard shortcuts for choices (A, B, C, D keys)
  document.addEventListener('keydown', (e) => {
    if (document.getElementById('answerContainer').classList.contains('active')) {
      switch(e.key.toLowerCase()) {
        case 'a':
          selectChoice(0);
          break;
        case 'b':
          selectChoice(1);
          break;
        case 'c':
          selectChoice(2);
          break;
        case 'd':
          selectChoice(3);
          break;
      }
    }
  });

  // Enter key submits wager
  document.getElementById('dailyDoubleWagerInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') submitDailyDoubleWager();
  });

  document.getElementById('wagerInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') submitWager();
  });

  document.getElementById('finalAnswer').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') submitFinalAnswer();
  });

  // Add hover sounds to interactive elements
  setTimeout(() => {
    document.querySelectorAll('.clue-cell, .buzz-button, .submit-button').forEach(element => {
      element.addEventListener('mouseenter', () => {
        if (!element.classList.contains('answered')) {
          hytopia.sendData({
            type: 'PLAY_SOUND',
            payload: { sound: 'hover' }
          });
        }
      });
    });
  }, 1000); // Wait for elements to be created
}

// Handle round change
function handleRoundChange(data) {
  showMessage(`Round ${data.round} Starting!`, 'info');
  gameState.round = data.round;
  updateRoundDisplay();
}

// Show game end
function showGameEnd(data) {
  const winner = Object.values(data.finalScores).reduce((a, b) =>
    a.score > b.score ? a : b
  );

  showMessage(`üèÜ ${winner.name} WINS with $${winner.score}!`, 'correct');

  // Show final scores
  setTimeout(() => {
    const modal = document.getElementById('finalModal');
    modal.innerHTML = `
      <h1 class="final-title">GAME OVER</h1>
      <div class="wager-container">
        <h2 style="color: var(--primary-gold); margin-bottom: 2rem;">Final Scores</h2>
        ${Object.values(data.finalScores).map(player => `
          <div style="margin: 1rem 0; font-size: 1.5rem;">
            <span style="color: var(--text-light);">${player.name}:</span>
            <span style="color: var(--primary-gold); font-weight: 700;">$${player.score}</span>
          </div>
        `).join('')}
        <button class="submit-button" onclick="location.reload()" style="margin-top: 2rem;">
          Play Again
        </button>
      </div>
    `;
    modal.classList.add('active');
  }, 3000);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeGame);
} else {
  initializeGame();
}
</script>